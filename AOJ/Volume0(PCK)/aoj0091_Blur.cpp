// Blur
// 図 1 のような 10×10 のマス目の「布」があり、（1，2）のようにX座標・Y座標の値の対でマス目を示すことにします。座標値は 0 から始まる整数とします。例えば、図 1 の◎の座標は (1, 2) です。 この「布」に染料を少しずつたらして染物を作ります。たらす染料の滴には「大」「中」「小」の 3 サイズがあり、染料の滴の落ちたマス目を中心に図 1 のように周囲も色がつきます。図 1 で☆が中心、○が色のにじむ範囲です。



// 「布」は、最初は「まっしろ」つまり、どのマス目も色の濃さを示す値が 0 とします。染料の滴が落ちるごとに値が 1 ずつ増えていきます。「小」が（1, 2）、「中」が（3, 2）に落ちた場合、各マス目の値は図 2 の左のようになります。染料がもったいないので、図 2 の右に示すようなにじむ範囲が布の外にはみ出すような染料の落とし方はしないことになっています。また、同じ場所に複数の染料をたらすこともあります。



// このような作業を何回か繰り返した結果、布にすばらしい模様が浮かび上がりましたが、残念なことに、うっかり作業経過を記録し忘れてしまいました。どうにもさっぱり思い出せませんが、かろうじて、落とした染料の滴数は覚えていました。あなたは、すばらしい染物を再現しなければなりません。すばらしい染物のデータを読みこんで、どこに、どのような染料をたらしたかを出力するプログラムを作成してください。なお、落とした染料の滴数は 12 以下とします。

// 入力
// 入力の形式は以下のとおりです：

// 最初の 1 行に落とした染料の滴数 n が与えられます。次の行から 10 行に各座標の色の濃さが空白区切りで与えられます。

// 出力
// 出力は n 行からなります。染料の滴の「大」を 3、「中」を 2、「小」を 1 で表し、落とした染料ごとに、そのX座標、Y座標、滴の大きさを空白で区切って1行に出力してください。

// 染料のたらし方はどのような順番で出力しても良いものとします。

#include <bits/stdc++.h>
using namespace std;
int n;
int maze[10][10];
int color[10][10];
vector<pair<pair<int,int>,int>> v;
// from aoj0026_DroppingInk
int dx[4][13] = {{},
    {0,1,2,1,1},
    {0,1,2,0,1,2,0,1,2},
    {0,1,2,3,4,1,2,3,1,2,3,2,2}
};
int dy[4][13] = {{},
    {0,0,0,-1,1},
    {0,0,0,1,1,1,2,2,2},
    {0,0,0,0,0,-1,-1,-1,1,1,1,-2,2}
};
int num[4] = {0,5,9,13};

bool check() {
    if (v.size() != n) return 0;
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            if (maze[i][j] != color[i][j]) return 0;
        }
    }
    return 1;
}

bool dfs(int x, int y) {
    if (y == 10) {
        x++;
        y = 0;
    }
    if (x == 10) return check();
    if (maze[x][y] - color[x][y] == 0) return dfs(x,y+1);
    for (int i = 1; i <= 3; i++) {
        bool ok = 1;
        for (int j = 0; j < num[i]; j++) {
            int tx = x + dx[i][j];
            int ty = y + dy[i][j];
            if (tx < 0 || tx >= 10 || ty < 0 || ty >= 10) {
                ok = 0;
                break;
            }
            if (maze[tx][ty] - color[tx][ty] < 1) {
                ok = 0;
                break;
            }
        }
        if (ok) {
            for (int j = 0; j < num[i]; j++) {
                int tx = x + dx[i][j];
                int ty = y + dy[i][j];
                color[tx][ty]++;
            }
            v.push_back({{x,y},i});
            if (dfs(x,y)) return 1;
            for (int j = 0; j < num[i]; j++) {
                int tx = x + dx[i][j];
                int ty = y + dy[i][j];
                color[tx][ty]--;
            }
            v.pop_back();
        }
    }
    return 0;
}

int main() {
    cin >> n;
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            cin >> maze[i][j];
        }
    }
    dfs(0,0);
    for (int i = 0; i < v.size(); i++) {
        int w = v[i].first.second;
        int h = v[i].first.first;
        int c = v[i].second;
        if (c == 1) {
            h++;
        } else if (c == 2) {
            h++;
            w++;
        } else {
            h += 2;
        }
        cout << w << " " << h << " " << c << endl;
    }
    return 0;
}