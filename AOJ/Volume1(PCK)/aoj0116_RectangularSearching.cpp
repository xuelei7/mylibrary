// 長方形探索
// 縦に H 行、横に W 列並べられた、合計 W×H のマス目があります。いくつかのマス目には印がついています。各マス目の印の状態を読み込み、印のついていないマス目だけからなる最大の長方形の面積を出力するプログラムを作成してください。

// 入力データは 1 行 W 文字から構成され、H 行が与えられます。たとえば以下のようなデータが与えられます。

// ..*....**.
// ..........
// **....***.
// ....*.....
// ..*.......
// ...**.....
// .*.*......
// ..........
// ..**......
// .*..*.....
// 入力データの一行が、一行のマス目を表現します。入力データの文字列のうち、. (ピリオド) は印のついていないマス目、* (アスタリスク) は印のついているマス目を示しています。入力データの文字列には、ピリオド、アスタリスク、改行以外の文字は含まれません。

// 上記の例では、下図の 0 で示される長方形が最大となります。

// ..*....**.
// ..........
// **....***.
// ....*00000
// ..*..00000
// ...**00000
// .*.*.00000
// .....00000
// ..**.00000
// .*..*00000
// よって、35 と出力すれば正解になります。なお、すべてのマス目に印がついている場合には、0 を出力してください。

// Input
// 複数のデータセットが与えられます。各データセットはスペースで区切られた H と W からなる行から始まり、つづいて H×W の長方形が与えられます。H,W はともに 500　以下とします。

// 入力は２つの 0 を含む行で終わります。データセットの数は 20 を超えません。

// Output
// 各データセットごとに、最大の長方形の面積を１行に出力してください。

// from aoj0092_SquareSearching

#include <bits/stdc++.h>
using namespace std;

char maze[1010][1010];
int dp[1010][1010];
int dp_yoko[1010][1010];

int main() {
    int h,w;
    while (cin >> h >> w) {
        if (h == 0 && w == 0) break;
        for (int i = 0; i < 1010; i++) {
            memset(dp[i],0,sizeof(dp[i]));
            memset(dp_yoko[i],0,sizeof(dp_yoko[i]));
        }
        for (int i = 0; i < h; i++) {
            cin >> maze[i];
            for (int j = w-1; j >= 0; j--) {
                if (maze[i][j] == '.') dp_yoko[i][j] = dp_yoko[i][j+1] + 1;
            }
        }
        int ans = 0;
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                if (maze[i][j] == '*') continue;
                int miw = w;
                for (int k = i; k < h; k++) {
                    miw = min(miw, dp_yoko[k][j]);
                    ans = max(ans, (k-i+1) * miw);
                }
            }
        }
        cout << ans << endl;
    }
    return 0;
}