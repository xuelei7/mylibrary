// 循環小数
// 2 つの正の整数 p, q を入力し、 p / q を小数として正確に表現することを考えます。(ただし、0 < p < q < 106とします。)

// このとき、結果は

// 有限の桁で正確に表現できる。
// ある桁の範囲を繰り返す循環小数となる。
// のいずれかとなります。筆算と同じ手順で1桁ずつ小数部を求めていくと、

// 割り切れた(余りが 0 になった)なら、そこまでの桁で正確に表現できた。
// 1度出てきた余りが、再び現れたなら、循環した。
// と区別できます。

// 2 つの整数 p, q を入力すると、 p / q を小数で表した時の、小数部を出力するプログラムを作成してください。 ただし、

// 結果が有限の桁で正確に表現できる時は、数値だけを 1 行に出力してください。
// 結果が循環小数になる時は次のように 2 行に出力してください。
// 最初の行に、循環する部分までの数字を出力してください。
// 次の行には、循環しない部分の下には空白を出力し、循環する部分の下には「^」を出力してください。
// いずれの場合も数字列は 80 文字を超えることはないものとします。
// Input
// 入力は複数のデータセットからなります。各データセットとして、p, q が空白区切りで１行に与えられます。データセットの数は 250 を超えません。

// Output
// データセットごとに、循環しない小数の場合は数値の小数部分を(この場合 1 行)、循環小数の場合は循環するまでの数字と循環する部分を示す記号「^」(この場合 2 行) を出力してください。

#include <bits/stdc++.h>
using namespace std;

int a[10000010];
int main() {
    int p,q;
    int tp, tq;
    while (cin >> p >> q) {
        p %= q;
        tp = p;
        tq = q;
        memset(a,0,sizeof(a));
        bool loop = 0;
        int cnt = 1, pre;
        a[p] = 1;
        while (p) {
            p *= 10;
            p %= q;
            if (p == 0) break;
            if (a[p] != 0) {
                loop = 1;
                pre = a[p];
                break;
            }
            cnt++;
            a[p] = cnt;
        }

        p = tp; q = tq;
        for (int i = 0; i < cnt; i++) {
            p %= q;
            p *= 10;
            cout << p / q;
        }
        cout << endl;
        if (loop) {
            for (int i = 0; i < pre - 1; i++) cout << " ";
            for (int i = pre - 1; i < cnt; i++) cout << "^";
            cout << endl;
        }
    }   
    return 0;
}