// Problem 3: 時空のスゴロク・ロード
// 全時空統一ディメンション・スゴロク・トーナメント。500 兆人を超える参加者の中から、ただ１人 のスゴロク絶対王者を決定するその大会に、あなたは２１世紀の地球代表として参加している。

// 今あなたが挑戦している課題は、自分自身をコマとした１次元スゴロク。端のスタートマスから出発 して、１から６までの目が一つずつ書かれた巨大な６面ダイスを振って出た目の数だけ進むことを繰 り返す、あなたもよく知っている形式のスゴロクだ。スタートマスとは反対の端にあるゴールマスに 止まるとゴールとなる。もちろん、ゴールするまでにサイコロを振った回数が少なければ少ないほど 良い成績となる。

// マスの中には特殊な効果を持ったマス「○マス進む」と「○マス戻る」が存在し、そこに止まってし まうと、指定されたマス数だけ進む、もしくは戻らなければならない。マスの効果で動いた結果、ふ たたび効果のあるマスに止まった場合は、続けて指示どおりに移動する。

// しかし、これは一筋縄では攻略できない時空スゴロクだ。恐るべきことに、たとえば「３マス進む」 の３マス先に「３マス戻る」が置かれていることもありうる。このようなマスに止まり、マスの効果 で無限ループに陥ってしまった場合は、永遠にマスを往復し続けなければならない。

// だが幸いなことに、あなたの身体には、望んだ事象を全事象に変えることのできる異能『確率湾曲』 が宿っている。この能力を使えば、サイコロの出目を自由に操ることも可能。このアドバンテージを 活かして、無限ループに陥らないようにしながら進んでいくとき、ゴールするまでにサイコロを振る 回数の最小値はいくつになるだろうか。

// Input
// N
// p1
// p2
// .
// .
// .
// pN
// 入力の１行目には、整数 N（3 ≤ N ≤ 100,000）が書かれている。これは、スゴロクのマス数をあらわす。マスには1 番からN 番までの番号がふられている。スタートのマスが1 番で、それからスタートに近い順に2 番、3 番、……、N - 1 番と続き、ゴールのマスがN 番である。i 番のマスでサイコロを振ってj の目が出たら、i + j 番のマスへと移動する。ただし、もしもi + j がN を超えていたら、余った数だけ戻ったりはせず、ゴールしたとみなされる。

// 続くN 行には、整数 pi（-100,000 ≤ pi ≤ 100,000）が書かれている。1 ＋ i 行目に書かれた整数 pi は、i 番のマスに書かれている指示をあらわす。pi > 0 ならば「pi マス進む」、pi < 0 ならば「-pi マス戻る」であり、pi = 0 ならばそのマスには何の効果もない。p1 とpN は必ず0 である。マスの効果で、スタートより前やゴールより後に移動しろと指示されることはない。

// なお、与えられるスゴロクは、ゴールすることが可能であると仮定してよい。

// Output
// ゴールするまでにサイコロを振る回数の最小値を出力せよ。

#include <bits/stdc++.h>
using namespace std;
int q[100110],p[100110];
int dp[100110];
bool used[100110];
int go(int k) {
    if (used[k]) return p[k];
    used[k] = 1;
    if (q[k] == 0) {
        return p[k] = k;
    }
    return p[k] = go(k+q[k]);
}
typedef pair<int,int> P;
struct edge{int to, cost;};
const int INF = 1e9;
int V;
const int MAX_V = 1e5;
vector<edge> G[MAX_V];
int d[MAX_V];

void dijkstra(int s, int *d, vector<edge> *G, int V) {
  priority_queue<P, vector<P>, greater<P>> que;
  fill(d, d + V, INF);
  d[s] = 0;
  que.push(P(0, s));

  while (!que.empty()) {
    P p = que.top();
    que.pop();
    int v = p.second;
    if (d[v] < p.first) continue;
    for (int i = 0; i < G[v].size(); i++) {
      edge e = G[v][i];
      if (d[e.to] > d[v] + e.cost) {
        d[e.to] = d[v] + e.cost;
        que.push(P(d[e.to], e.to));
      }
    }
  }
}

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) cin >> q[i];
    for (int i = 0; i < n; i++) p[i] = -2;
    for (int i = 0; i < n; i++) go(i);
    // for (int i = 0; i < n; i++) cout << setw(5) << q[i] << " ";
    // cout << endl; 
    // for (int i = 0; i < n; i++) cout << setw(5) << p[i] << " ";
    // cout << endl; 

    for (int i = 0; i < n; i++) {
        if (p[i] == -2) continue;
        for (int j = 1; j <= 6; j++) {
            if (p[i+j]==-2) continue;
            G[i].push_back({p[i+j],1});
        }
    }

    dijkstra(0,dp,G,n);

    // for (int i = 0; i < n; i++) {
    //     cout << setw(5) << dp[i] << " ";
    // }
    // cout << endl;
    cout << dp[n-1] << endl;
    return 0;
}